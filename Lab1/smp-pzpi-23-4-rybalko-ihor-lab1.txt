Харківський національний університет радіоелектроніки
Факультет комп’ютерних наук
Катедра програмної інженерії

ЗВІТ
з лабораторної роботи № 1
з дисципліни «Скриптові мови програмування»
на тему: «Програмування у скриптовій мові shell (bash)»

Виконав
ст. гр. ПЗПІ-23-4
Рибалко Ігор

Перевірив
ст. викладач катедри ПІ
Сокорчук Ігор Петрович

Харків 2025

1 ІСТОРІЯ ЗМІН
№     Дата     Версія звіту   Опис змін та виправлень
1   07.05.25       0.1        Створено розділи «Історія змін», «Завдання», «Опис виконаної роботи», «Висновки»
	
2 ЗАВДАННЯ
Під час лабораторної роботи необхідно розробити Bash-скрипт, який обробляє експортований із сайту https://cist.nure.ua/ розклад занять для всіх груп потоку в форматі CSV та перетворює його у формат CSV для завантаження в Google Календар https://support.google.com/.
Також скрипт повинен мати такі характеристики та правила:
1. Мати ключі: --help — має вивести довідку, завершити роботу та повернути успішний результат у батьківський процес; --version — має вивести інформацію про версію, завершити роботу та повернути успішний результат у батьківський процес; -q або --quiet — повинен не виводити інформацію в стандартний потік виведення
2. Якщо при виклику скрипта не вказана академічна група або вхідний CSV файл, то вивести меню вибору файла за допомогою команди select та сформувати відсортований за датою в іменах файлів (від старіших до новіших) список доступних у поточній директорії CSV файлів за шаблоном:
TimeTable_??_??_20??.csv. 
А також відкрити вибраний CSV файл та згенерувати список академічних груп, що містяться у файлі, відсортувати їх за алфавітом (sort, uniq) та вивести меню вибору групи за допомогою select
   3. Читати вхідний CSV файл та вибирати рядки, що відповідають вибраній академічній групі.
   4. Визначити порядкий номер для кожного заняття (лекція, практичне заняття, лабораторна робота) із врахуванням того, що лабораторні роботи складаються із двох пар, а решта занять — із однієї пари
   5. Створити поле «Subject» із поля «Тема» вхідного CSV файла, але БЕЗ назви академічної групи та дефіса на початку цього поля ("ПЗПІ-23-1 - ПрПА Пз DL ПЗПІ-23-1")
   6. Додати порядковий номер наприкінці теми (Subject) кожного заняття після крапки з комою (опис заняття; №1)
   7. Переформатувати дату та час до формату «mm/dd/yyyy, HH:MM AM|PM,» Gogle Календаря 12-годинний формат часу. Наприклад: 02/30/2025, 11:15 AM,
   8. Заповнити поле «Description» текстом із поля «Опис (Описание)» вхідного CSV файла
   9. Відформатувати дані відповідно до вимог Google Календаря https://support.google.com/calendar/.
   10. Виводити створені для Google Календаря дані у стандартний потік виведення, якщо це не заблоковано ключем -q або --quiet
   11. Записати результат у новий файл із назвою:
Google_TimeTable_??_??_20??.csv
де ??_??_20?? — дата, що відповідає вхідному файлу.

3 ОПИС ВИКОНАНОЇ РОБОТИ
Для початку виконання завдання з ключами (--help; --version; -q чи --quiet), групами та аналізом вхідного файлу типу .csv для подальшого оформлення формату для Google-Календар було створено відповідні поля та цикл while, який поетапно обробляє всі аргументи командного рядка. Цей цикл дозволяє гнучко розпізнавати як службові ключі, так і вхідні дані, що забезпечує чіткий контроль над логікою запуску скрипта. (див. фрагмент коду А.1)
Наступний пунктом нашої роботи є обробка умови, при якій користувач не вказує вхідний CSV файл, тому за умовою задачі є вивести меню вибору файла за допомогою команди select та сформувати відсортований за датою в іменах файлів (від старіших до новіших) список доступних у поточній директорії CSV файлів за шаблоном: TimeTable_??_??_20??.csv., при цьому обробляємо різні сценарії: відсутність взагалі файлів у директорії, неправильна назва файлу тощо. (див. фрагмент коду А.2)
Далі у нас йде визначення групи для якої створюється розклад у Google-Календар. Група вже може бути вказана при запуску скрипта, але якщо не вказана, то аналізуючи файл ми повинні зрозуміти, чи там розклад однієї групи чи 2 і більше, щоб надати користувачу відсортований список груп (sort, uniq), з поміж якого, можливо створити розклад для однієї обраної групи.  (див. фрагмент коду А.3)
І якщо подивитись вхідний файл з сайту https://cist.nure.ua/, то ми можемо побачити, що розклад однієї групи по формату, не сильно відрізняється від розкладу, де представлено розклади інших груп, але все ж це вносить свої корективи, і далі ми повинні врахувати вже, який в нас файл, щоб виконати завдання "ПЗПІ-23-1 - ПрПА Пз DL ПЗПІ-23-1", де ми повинні прибрати “ПЗПІ-23-1 - ”. Тому вводимо змінну MODE, яка буде відповідати за тип розклад: одна група чи розклад багатоьх груп. І також виведемо ще необроблений розклад групи, якщо не встановлено ключ -q чи --quiet. (див. фрагмент коду А.4)
Тепер переходимо до формування CSV-Календаря. Він буде проходити у три етапи. Але перед цим оголосимо про початок його формування та тимчасові файли tmp_data; sorted_data, які будуть відігравати важливу роль у сортуванні предметів за часом, що важливо для календаря. 

Тому 1 етап (див. фрагмент А.5) розпочинаємо з використання комбінацій команд sed, iconv і awk, щоб перекодувати файл у UTF-8, позбутись символів Windows-переносу рядків (\r), і зчитати саму суть розкладу в структурованому вигляді. Визначаємо функції сортування ключів та прибирання лапок з початку та кінця текстових полів. Далі йде реалізація блоку, що  знаходить дату у форматі dd.mm.yyyy у рядку та ділить його на дві частини: все до дати (field1) і решта (rest). Потім вручну розбиває rest на поля CSV, враховуючи лапки, щоб правильно врахувати коми в середині лапок. Якщо полів менше 12 — такий рядок пропускається як неповний.
Тепер використовуємо наший MODE, тобто якщо режим singleGroup, то назву предмета (subject) просто беруть з поля до дати. Інакше, з field1 витягується назва групи й порівнюється з обраною — якщо вона не збігається, рядок ігнорується; інакше — видаляється частина з назвою групи. Далі за ключовими словами в полі desc визначається тип заняття (Лб, Лк, Пз, Екз), формується ключ сортування і виводяться всі потрібні поля, які передаються у tmp_data - тимчасовий файл.
Далі йде другий етап - сортування наших рядків за зробленим ключем сортувальною датою. (див. фрагмент А.6)
Фінальний третій етап (див. фрагмент А.7) - використовуємо awk для обробки відсортованих даних у форматі табуляції (sorted_data). Спочатку виводимо заголовки для CSV-файлу: "Subject", "Start Date", "Start Time", "End Date", "End Time", "Description". Далі реалізуємо, функції format_date і format_time, які перетворюють дати та час з формату DD.MM.YYYY та HH:MM у відповідні формати для Google Календаря (MM/DD/YYYY і 12-годинний формат часу). Генеруємо унікальні ключі для кожного заняття на основі предмета та дати. Якщо заняття є лабораторним, то перевіряється, чи вже було таке заняття в цей день, якщо так, то номер залишається як у попердньої лабораторної, якщо ні - то новий номер. Також формується повна назва предмета, дату і час початку/закінчення, і опис. В результаті, ці дані виводяться у форматі CSV у файл output_file, що готовий для імпорту в Google Календар.
Також в кінці написано перевірку змінної QUEIT. Якщо true, то виводиться вміст файлу $output_file. У будь-якому разі виводиться повідомлення “Google-file сформований”. На завершення видаляються тимчасові файли $tmp_data та $sorted_data. (див. фрагмент А.8)


4 ВИСНОВКИ
У результаті виконання лабораторної роботи було створено Bash-скрипт, який обробляє експортований із сайту https://cist.nure.ua/ розклад занять для всіх груп потоку в форматі CSV та перетворює його у формат CSV для завантаження в Google Календар https://support.google.com/.


ДОДАТОК А
Програмний код
GitHub репозиторій: https://github.com/NureRybalkoIhor/smp-pzpi-23-4-rybalko-ihor/blob/main/Lab1/smp-pzpi-23-4-rybalko-ihor-lab1/smp-pzpi-23-4-rybalko-ihor-lab1-code 
А.1 Обробка аргументів командного рядка для керування режимами скрипта
  1 #!/bin/bash
  2
  3 VERSION="1.0"
  4 INPUT_FILE=""
  5 GROUP=""
  6 QUIET=false
  7
  8 while [[ $# -gt 0 ]]; do
  9     arg="$1"
 10
 11     if [[ "$arg" == "--help" ]]; then
 12         echo "Використання: $0 [--help | --version] | [[-q|--quiet] [академ_група] файл_із_cist.csv]"
 13         echo "  --help        Відображення довідки"
 14         echo "  --version     Відображення версію скрипта"
 15         echo "  -q, --quiet   Не виводити вміст TimeTable_.._.._20.. та сформованого Google_.._.._20.. файлів у stdout"
 16         exit 0
 17
 18     elif [[ "$arg" == "--version" ]]; then
 19         echo "Версія: $VERSION"
 20         exit 0
 21
 22     elif [[ "$arg" == "-q" || "$arg" == "--quiet" ]]; then
 23         QUIET=true
 24
 25     elif [[ "$arg" == *.csv ]]; then
 26         INPUT_FILE="$arg"
 27
 28     else
 29         GROUP="$arg"
 30     fi
 31
 32     shift
 33 done
 34
А.2 Автоматичний вибір вхідного файлу розкладу з директорії та перевірка його наявності
 35 if [ -z "$INPUT_FILE" ]; then
 36
 37     files=($(ls | grep -E '^TimeTable_.._.._20..\.csv'))
 38
 39     if [ ${#files[@]} -eq 0 ]; then
 40         echo "Помилка: файли TimeTable_ДД_ММ_РРРР.csv не знайдено" >&2
 41         exit 1
 42     fi
 43
 44     sorted_files=()
 45     for file in "${files[@]}"; do
 46
 47         day=${file:10:2}
 48         month=${file:13:2}
 49         year=${file:16:4}
 50
 51         sorted_files+=("${year}${month}${day} $file")
 52     done
 53
 54     sorted_files=($(printf "%s\n" "${sorted_files[@]}" | sort | awk '{print $2}'))
 55
 56     sorted_files+=("Вийти")
 57
 58     echo "Оберіть файл із розкладом:"
 59     select chosen_file in "${sorted_files[@]}"; do
 60         if [ "$chosen_file" = "Вийти" ]; then
 61             echo "Вихід із програми."
 62             exit 0
 63         fi
 64
 65         if [ -n "$chosen_file" ]; then
 66             echo "Обрано файл: $chosen_file"
 67             INPUT_FILE="$chosen_file"
 68             break
 69         else
 70             echo "Помилка: виберіть номер зі списку."
 71         fi
 72     done
 73 fi
 74
 75 if [ ! -f "$INPUT_FILE" ]; then
 76     echo "Помилка: файлу $INPUT_FILE немає у поточній директорії. Передивіться ще раз назву та розширення файлу .csv" >&2
 77     exit 2
 78 fi
 79




А.3 Аналіз CSV-файлу для отримання списку груп та інтерактивний вибір груп
 80 groups=($(cat "$INPUT_FILE" | sed 's/\r/\n/g' | iconv -f cp1251 -t utf-8 | awk '
 81     BEGIN { FPAT="[^,]*|\"[^\"]*\"" }
 82     NR > 1 {
 83         gsub(/^"|"$/, "", $1)
 84         split($1, words, " ")
 85         for (i = 1; i <= length(words); i++) {
 86             if (words[i] ~ /^ПЗПІ-23-[0-9]+$/) {
 87                 print words[i]
 88             }
 89         }
 90     }' | sort | uniq | sort -t '-' -k 3 -n))
 91
 92 if [ ${#groups[@]} -eq 0 ]; then
 93     echo "Помилка: у файлі $INPUT_FILE не знайдено груп ПЗПІ-23-?" >&2
 94     exit 3
 95 fi
 96
 97 if [ -n "$GROUP" ] && [ ${#groups[@]} -eq 1 ] && [ "$GROUP" != "${groups[0]}" ]; then
 98     echo "Цей файл містить лише розклад для групи: ${groups[0]}"
 99     exit 0
100 fi
101
102 if [ -z "$GROUP" ]; then
103     if [ ${#groups[@]} -eq 1 ]; then
104         GROUP="${groups[0]}"
105         echo "Одна доступна група: $GROUP"
106     else
107         echo "Доступні групи:"
108         groups+=("Повернутись")
109         select chosen_group in "${groups[@]}"; do
110             if [ "$chosen_group" = "Повернутись" ]; then
111                 echo "Повернення до вибору файлу."
112                 exit 0
113             elif [ -n "$chosen_group" ]; then
114                 echo "Обрано групу: $chosen_group"
115                 GROUP="$chosen_group"
116                 break
117             else
118                 echo "Помилка: зробіть правильний вибір (номер зі списку)."
119             fi
120         done
121     fi
122 fi
123
А.4 Визначення формату розкладу: одна група чи кілька (режим singleGroup/multiGroup)
124 mode=$(cat "$INPUT_FILE" | sed 's/\r/\n/g' | iconv -f cp1251 -t utf-8 | awk '
125     BEGIN { FPAT="[^,]*|\"[^\"]*\"" }
126     NR > 1 {
127         gsub(/^"|"$/, "", $1)
128         split($1, words, " ")
129         if (words[0] ~ /^ПЗПІ-23-[0-9]+$/) {
130             print "multiGroup"
131             exit
132         } else if (words[4] ~ /^ПЗПІ-23-[0-9]+$/) {
133             print "singleGroup:" words[4]
134             exit
135         }
136     }')
137
138 if [[ "$mode" =~ ^singleGroup:(.*) ]]; then
139     GROUP="${BASH_REMATCH[1]}"
140     SELECTED_GROUP="$GROUP"
141     MODE="singleGroup"
142
143     if [ "$QUIET" = "false" ]; then
144                 echo "У файлі знайдено розклад лише для однієї групи: $GROUP"
145                 echo "Розклад для $GROUP:"
146
147             # Вивести всі рядки, що відповідають одній групі
148             cat "$INPUT_FILE" | sed 's/\r/\n/g' | iconv -f cp1251 -t utf-8
149     fi
150
151 else
152     MODE="multiGroup"
153     SELECTED_GROUP="$GROUP"
154     echo "Розклад для групи: $GROUP"
155     if [ "$QUIET" = "false" ]; then
156         cat "$INPUT_FILE" | sed 's/\r/\n/g' | iconv -f cp1251 -t utf-8 | awk -v group="$GROUP" '
157             BEGIN { FPAT="[^,]*|\"[^\"]*\"" }
158             NR == 1 { print; next }
159             {
160                 gsub(/^"|"$/, "", $1)
161                 if ($1 ~ (group ",")) { next }
162                 split($1, words, /[ ,;]+/)
163                     for (i = 1; i <= length(words); i++) {
164                         gsub(/^ +| +$/, "", words[i])
165                         if (words[i] == group) {
166                                 print
167                             break
168                         }
169                     }
170             }'
171     fi
172 fi
173
А.5 Формування структурованих записів для календаря: підготовка та фільтрація CSV-рядків
174 
175 # Формуємо CSV для Google Календаря
176 # Вихідний файл
177 output_file=$(echo "$INPUT_FILE" | sed 's/TimeTable/Google_TimeTable/')
178 echo "Формування розкладу для Google Календаря: $output_file"
179
180 tmp_data=$(mktemp)
181 sorted_data=$(mktemp)
182
183 sed 's/\r/\n/g' "$INPUT_FILE" | iconv -f cp1251 -t utf-8 | awk -v GROUP="$GROUP" -v MODE="$MODE" '
184 BEGIN {
185     FS=","; OFS="\t"
186 }
187 NR == 1 { next }
188
189 function format_sort_key(date, time) {
190     split(date, dmy, ".")
191     split(time, hm, ":")
192     return sprintf("%04d%02d%02d%02d%02d", dmy[3], dmy[2], dmy[1], hm[1], hm[2])
193 }
194
195 function trim_quotes(s) {
196     gsub(/^"|"$/, "", s)
197     return s
198 }
199
200 {
201     line = $0
202     match(line, /"[0-3][0-9]\.[0-1][0-9]\.[0-9]{4}"/)
203     if (RSTART == 0) next
204
205     field1 = substr(line, 1, RSTART - 2)
206     rest = substr(line, RSTART)
207
208     n = 0; in_quotes = 0; field = ""
209     for (i = 1; i <= length(rest); i++) {
210         c = substr(rest, i, 1)
211         if (c == "\"") in_quotes = !in_quotes
212         else if (c == "," && !in_quotes) {
213             fields[++n] = field
214             field = ""
215         } else {
216             field = field c
217         }
218     }
219     fields[++n] = field
220     for (i = 1; i <= n; i++) fields[i] = trim_quotes(fields[i])
221     if (n < 12) next
222
223 if (MODE == "singleGroup") {
224     subject = trim_quotes(field1)
225 }
226 else {
227
228     match(field1, /(ПЗПІ-[0-9]+-[0-9]+)[[:space:]]*-[[:space:]]*/, m)
229     found_group = m[1]
230
231     if (found_group != GROUP)
232         next
233
234     field1 = substr(field1, RSTART + RLENGTH)
235     gsub(/^[[:space:]]+/, "", field1)
236     subject = field1
237     gsub(/^"|"$/, "", subject)
238 }
239
240     desc = fields[11]
241     type = "Інше"
242
243     if (desc ~ /Лб/)
244         type = "Лб"
245     else if (desc ~ /Лк/)
246         type = "Лк"
247     else if (desc ~ /Пз/)
248         type = "Пз"
249     else if (desc ~ /Екз/i)
250         type = "Екз"
251
252     sort_key = format_sort_key(fields[1], fields[2])
253
254     print subject, type, fields[1], fields[2], fields[3], fields[4], desc, sort_key
255 }' > "$tmp_data"
256
А.6 Хронологічне сортування записів для календаря
257 sort -t $'\t' -k8,8 "$tmp_data" > "$sorted_data"
258
А.7 Генерація фінального CSV: підготовка до імпорту
259 awk -F'\t' '
260 BEGIN {
261     OFS = ","
262     print "Subject", "Start Date", "Start Time", "End Date", "End Time", "Description"
263 }
264
265 function format_date(date) {
266     split(date, dmy, ".")
267     return sprintf("%02d/%02d/%04d", dmy[2], dmy[1], dmy[3])
268 }
269
270 function format_time(time) {
271     split(time, hmin, ":")
272     h = hmin[1] + 0
273     min = hmin[2]
274     ap = (h >= 12) ? "PM" : "AM"
275     if (h == 0) h = 12
276     else if (h > 12) h -= 12
277     return sprintf("%02d:%s %s", h, min, ap)
278 }
279 {
280     subj_key = $1 "_" $2
281     date_key = $3 "_" $7
282
283     if ($2 == "Лб") {
284         if (!(date_key in lab_seen)) {
285             count[subj_key]++
286             lab_seen[date_key] = count[subj_key]
287         }
288         number = lab_seen[date_key]
289     } else {
290         count[subj_key]++
291         number = count[subj_key]
292     }
293
294     subject_full = $1 "; №" number
295     start_date = format_date($3)
296     start_time = format_time($4)
297     end_date = format_date($5)
298     end_time = format_time($6)
299     desc = $7
300
301     printf "\"%s\",\"%s\",\"%s\",\"%s\",\"%s\",\"%s\"\n", \
302         subject_full, start_date, start_time, end_date, end_time, desc
303 }' "$sorted_data" > "$output_file"
304


А.8 Післяобробка: вивід CSV і прибирання тимчасових файлів
305 if [[ "$QUIET" == false ]]; then
306     cat "$output_file"
307     echo "Google-file сформований"
308 else
309     echo "Google-file сформований"
310 fi
311
312 echo "Назва вихідного файлу: $output_file"
313
314 rm -f "$tmp_data" "$sorted_data"
