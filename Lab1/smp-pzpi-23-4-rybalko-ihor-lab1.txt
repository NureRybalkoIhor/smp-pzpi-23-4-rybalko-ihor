Харківський національний університет радіоелектроніки
Факультет комп’ютерних наук
Катедра програмної інженерії

ЗВІТ
з лабораторної роботи № 1
з дисципліни «Скриптові мови програмування»
на тему: «Програмування у скриптовій мові shell (bash)»

Виконав
ст. гр. ПЗПІ-23-4
Рибалко Ігор

Перевірив
ст. викладач катедри ПІ
Сокорчук Ігор Петрович

Харків 2025

1 ІСТОРІЯ ЗМІН
№     Дата     Версія звіту   Опис змін та виправлень
1   07.05.25       0.1        Створено розділи «Історія змін», «Завдання», «Опис виконаної роботи», «Висновки»
2   13.05.25       0.2        Внесення змін до додатків А, Б

2 ЗАВДАННЯ
Під час лабораторної роботи необхідно розробити Bash-скрипт, який обробляє експортований із сайту https://cist.nure.ua/ розклад занять для всіх груп потоку в форматі CSV та перетворює його у формат CSV для завантаження в Google Календар https://support.google.com/.
Також скрипт повинен мати такі характеристики та правила:
1. Мати ключі: --help — має вивести довідку, завершити роботу та повернути успішний результат у батьківський процес; --version — має вивести інформацію про версію, завершити роботу та повернути успішний результат у батьківський процес; -q або --quiet — повинен не виводити інформацію в стандартний потік виведення
2. Якщо при виклику скрипта не вказана академічна група або вхідний CSV файл, то вивести меню вибору файла за допомогою команди select та сформувати відсортований за датою в іменах файлів (від старіших до новіших) список доступних у поточній директорії CSV файлів за шаблоном:
TimeTable_??_??_20??.csv. 
А також відкрити вибраний CSV файл та згенерувати список академічних груп, що містяться у файлі, відсортувати їх за алфавітом (sort, uniq) та вивести меню вибору групи за допомогою select
   3. Читати вхідний CSV файл та вибирати рядки, що відповідають вибраній академічній групі.
   4. Визначити порядкий номер для кожного заняття (лекція, практичне заняття, лабораторна робота) із врахуванням того, що лабораторні роботи складаються із двох пар, а решта занять — із однієї пари
   5. Створити поле «Subject» із поля «Тема» вхідного CSV файла, але БЕЗ назви академічної групи та дефіса на початку цього поля ("ПЗПІ-23-1 - ПрПА Пз DL ПЗПІ-23-1")
   6. Додати порядковий номер наприкінці теми (Subject) кожного заняття після крапки з комою (опис заняття; №1)
   7. Переформатувати дату та час до формату «mm/dd/yyyy, HH:MM AM|PM,» Google Календаря 12-годинний формат часу. Наприклад: 02/30/2025, 11:15 AM,
   8. Заповнити поле «Description» текстом із поля «Опис (Описание)» вхідного CSV файла
   9. Відформатувати дані відповідно до вимог Google Календаря https://support.google.com/calendar/.
   10. Виводити створені для Google Календаря дані у стандартний потік виведення, якщо це не заблоковано ключем -q або --quiet
   11. Записати результат у новий файл із назвою:
Google_TimeTable_??_??_20??.csv
де ??_??_20?? — дата, що відповідає вхідному файлу.

3 ОПИС ВИКОНАНОЇ РОБОТИ
Для початку виконання завдання з ключами (--help; --version; -q чи --quiet), групами та аналізом вхідного файлу типу .csv для подальшого оформлення формату для Google-Календар було створено відповідні поля та цикл while, який поетапно обробляє всі аргументи командного рядка. Цей цикл дозволяє гнучко розпізнавати як службові ключі, так і вхідні дані, що забезпечує чіткий контроль над логікою запуску скрипта. (див. фрагмент коду Б.1)
Наступний пунктом нашої роботи є обробка умови, при якій користувач не вказує вхідний CSV файл, тому за умовою задачі є вивести меню вибору файла за допомогою команди select та сформувати відсортований за датою в іменах файлів (від старіших до новіших) список доступних у поточній директорії CSV файлів за шаблоном: TimeTable_??_??_20??.csv., при цьому обробляємо різні сценарії: відсутність взагалі файлів у директорії, неправильна назва файлу тощо. (див. фрагмент коду Б.2)
Далі у нас йде визначення групи для якої створюється розклад у Google-Календар. Група вже може бути вказана при запуску скрипта, але якщо не вказана, то аналізуючи файл ми повинні зрозуміти, чи там розклад однієї групи чи 2 і більше, щоб надати користувачу відсортований список груп (sort, uniq), з поміж якого, можливо створити розклад для однієї обраної групи.  (див. фрагмент коду Б.3)
І якщо подивитись вхідний файл з сайту https://cist.nure.ua/, то ми можемо побачити, що розклад однієї групи по формату не сильно відрізняється від розкладу, де представлено розклади інших груп, але все ж це вносить свої корективи, і далі ми повинні врахувати вже, який в нас файл, щоб виконати завдання "ПЗПІ-23-1 - ПрПА Пз DL ПЗПІ-23-1", де ми повинні прибрати “ПЗПІ-23-1 - ”. Тому вводимо змінну MODE, яка буде відповідати за тип розклад: одна група чи розклад багатоьх груп. І також виведемо ще необроблений розклад групи, якщо не встановлено ключ -q чи --quiet. (див. фрагмент коду Б.4)
Тепер переходимо до формування CSV-Календаря. Він буде проходити у три етапи. Але перед цим оголосимо про початок його формування та тимчасові файли tmp_data; sorted_data, які будуть відігравати важливу роль у сортуванні предметів за часом, що важливо для календаря. 
Тому 1 етап (див. фрагмент Б.5) розпочинаємо з використання комбінацій команд sed, iconv і awk, щоб перекодувати файл у UTF-8, позбутись символів Windows-переносу рядків (\r), і зчитати саму суть розкладу в структурованому вигляді. Визначаємо функції сортування ключів та прибирання лапок з початку та кінця текстових полів. Далі йде реалізація блоку, що  знаходить дату у форматі dd.mm.yyyy у рядку та ділить його на дві частини: все до дати (field1) і решта (rest). Потім вручну розбиває rest на поля CSV, враховуючи лапки, щоб правильно врахувати коми в середині лапок. Якщо полів менше 12 — такий рядок пропускається як неповний.
Тепер використовуємо наший MODE, тобто якщо режим singleGroup, то назву предмета (subject) просто беруть з поля до дати. Інакше, з field1 витягується назва групи й порівнюється з обраною — якщо вона не збігається, рядок ігнорується; інакше — видаляється частина з назвою групи. Далі за ключовими словами в полі desc визначається тип заняття (Лб, Лк, Пз, Екз), формується ключ сортування і виводяться всі потрібні поля, які передаються у tmp_data - тимчасовий файл.
Далі йде другий етап - сортування наших рядків за зробленим ключем сортувальною датою. (див. фрагмент Б.6)
Фінальний третій етап (див. фрагмент Б.7) - використовуємо awk для обробки відсортованих даних у форматі табуляції (sorted_data). Спочатку виводимо заголовки для CSV-файлу: "Subject", "Start Date", "Start Time", "End Date", "End Time", "Description". Далі реалізуємо, функції format_date і format_time, які перетворюють дати та час з формату DD.MM.YYYY та HH:MM у відповідні формати для Google Календаря (MM/DD/YYYY і 12-годинний формат часу). Генеруємо унікальні ключі для кожного заняття на основі предмета та дати. Якщо заняття є лабораторним, то перевіряється, чи вже було таке заняття в цей день, якщо так, то номер залишається як у попердньої лабораторної, якщо ні - то новий номер. Також формується повна назва предмета, дату і час початку/закінчення, і опис. В результаті, ці дані виводяться у форматі CSV у файл output_file, що готовий для імпорту в Google Календар.
Також в кінці написано перевірку змінної QUIET. Якщо true, то виводиться вміст файлу $output_file. У будь-якому разі виводиться повідомлення “Google-file сформований”. На завершення видаляються тимчасові файли $tmp_data та $sorted_data. (див. фрагмент Б.8)

4 ВИСНОВКИ
У результаті виконання лабораторної роботи було створено Bash-скрипт, який обробляє експортований із сайту https://cist.nure.ua/ розклад занять для всіх груп потоку в форматі CSV та перетворює його у формат CSV для завантаження в Google Календар https://support.google.com/.

ДОДАТОК А
Відеозапис
Відеозапис презентації результатів лабораторної роботи: https://www.youtube.com/watch?v=fMkAnZ_UJlY 
Хронологічний опис відеозапису:
00:00 - Обробка аргументів командного рядка для керування режимами скрипта
00:46 - Автоматичний вибір вхідного файлу розкладу з директорії та перевірка його наявності
01:47 - Аналіз CSV-файлу для отримання списку груп та інтерактивний вибір груп
03:10 - Визначення формату розкладу: одна група чи кілька (режим singleGroup/multiGroup)
04:41 - Формування структурованих записів для календаря: підготовка та фільтрація CSV-рядків
08:30 - Хронологічне сортування записів для календаря + Генерація фінального CSV: підготовка до імпорт
09:56 - Післяобробка: вивід CSV і прибирання тимчасових файлів

ДОДАТОК Б
Програмний код
GitHub репозиторій: https://github.com/NureRybalkoIhor/smp-pzpi-23-4-rybalko-ihor/blob/main/Lab1/smp-pzpi-23-4-rybalko-ihor-lab1/smp-pzpi-23-4-rybalko-ihor-lab1-code 
Б.1 Обробка аргументів командного рядка для керування режимами скрипта
  1 #!/bin/bash
  2
  3 VERSION="1.0"
  4 INPUT_FILE=""
  5 GROUP=""
  6 QUIET=false
  7
  8 while [[ $# -gt 0 ]]; do
  9     arg="$1"
 10
 11     if [[ "$arg" == "--help" ]]; then
 12         echo "Використання: $0 [--help | --version] | [[-q|--quiet] [академ_група] файл_із_cist.csv]"
 13         echo "  --help        Відображення довідки"
 14         echo "  --version     Відображення версію скрипта"
 15         echo "  -q, --quiet   Не виводити вміст TimeTable_.._.._20.. та сформованого Google_.._.._20.. файлів у stdout"
 16         exit 0
 17
 18     elif [[ "$arg" == "--version" ]]; then
 19         echo "Версія: $VERSION"
 20         exit 0
 21
 22     elif [[ "$arg" == "-q" || "$arg" == "--quiet" ]]; then
 23         QUIET=true
 24
 25     elif [[ "$arg" == *.csv ]]; then
 26         INPUT_FILE="$arg"
 27
 28     else
 29         GROUP="$arg"
 30     fi
 31
 32     shift
 33 done
 34
Б.2 Автоматичний вибір вхідного файлу розкладу з директорії та перевірка його наявності
 35 if [ -z "$INPUT_FILE" ]; then
 36
 37     files=($(ls | grep -E '^TimeTable_.._.._20..\.csv'))
 38
 39     if [ ${#files[@]} -eq 0 ]; then
 40         echo "Помилка: файли TimeTable_ДД_ММ_РРРР.csv не знайдено" >&2
 41         exit 1
 42     fi
 43
 44     sorted_files=()
 45     for file in "${files[@]}"; do
 46
 47         day=${file:10:2}
 48         month=${file:13:2}
 49         year=${file:16:4}
 50
 51         sorted_files+=("${year}${month}${day} $file")
 52     done
 53
 54     sorted_files=($(printf "%s\n" "${sorted_files[@]}" | sort | awk '{print $2}'))
 55
 56     sorted_files+=("Вийти")
 57
 58     echo "Оберіть файл із розкладом:"
 59     select chosen_file in "${sorted_files[@]}"; do
 60         if [ "$chosen_file" = "Вийти" ]; then
 61             echo "Вихід із програми."
 62             exit 0
 63         fi
 64
 65         if [ -n "$chosen_file" ]; then
 66             echo "Обрано файл: $chosen_file"
 67             INPUT_FILE="$chosen_file"
 68             break
 69         else
 70             echo "Помилка: виберіть номер зі списку."
 71         fi
 72     done
 73 fi
 74
 75 if [ ! -f "$INPUT_FILE" ]; then
 76     echo "Помилка: файлу $INPUT_FILE немає у поточній директорії. Передивіться ще раз назву та розширення файлу .csv" >&2
 77     exit 2
 78 fi
 79


Б.3 Аналіз CSV-файлу для отримання списку груп та інтерактивний вибір груп
 80 groups=($(cat "$INPUT_FILE" | sed 's/\r/\n/g' | iconv -f cp1251 -t utf-8 | awk '
 81     BEGIN { FPAT="[^,]*|\"[^\"]*\"" }
 82     NR > 1 {
 83         gsub(/^"|"$/, "", $1)
 84         split($1, words, " ")
 85         for (i = 1; i <= length(words); i++) {
 86             if (words[i] ~ /^ПЗПІ-23-[0-9]+$/) {
 87                 print words[i]
 88             }
 89         }
 90     }' | sort | uniq | sort -t '-' -k 3 -n))
 91
 92 if [ ${#groups[@]} -eq 0 ]; then
 93     echo "Помилка: у файлі $INPUT_FILE не знайдено груп ПЗПІ-23-?" >&2
 94     exit 3
 95 fi
 96
 97 if [ -n "$GROUP" ] && [ ${#groups[@]} -eq 1 ] && [ "$GROUP" != "${groups[0]}" ]; then
 98     echo "Цей файл містить лише розклад для групи: ${groups[0]}"
 99     exit 0
100 fi
101
102 if [ -z "$GROUP" ]; then
103     if [ ${#groups[@]} -eq 1 ]; then
104         GROUP="${groups[0]}"
105         echo "Одна доступна група: $GROUP"
106     else
107         echo "Доступні групи:"
108         groups+=("Повернутись")
109         select chosen_group in "${groups[@]}"; do
110             if [ "$chosen_group" = "Повернутись" ]; then
111                 echo "Повернення до вибору файлу."
112                 exit 0
113             elif [ -n "$chosen_group" ]; then
114                 echo "Обрано групу: $chosen_group"
115                 GROUP="$chosen_group"
116                 break
117             else
118                 echo "Помилка: зробіть правильний вибір (номер зі списку)."
119             fi
120         done
121     fi
122 fi
123
Б.4 Визначення формату розкладу: одна група чи кілька (режим singleGroup/multiGroup)
124 mode=$(cat "$INPUT_FILE" | sed 's/\r/\n/g' | iconv -f cp1251 -t utf-8 | awk '
125     BEGIN { FPAT="[^,]*|\"[^\"]*\"" }
126     NR > 1 {
127         gsub(/^"|"$/, "", $1)
128         split($1, words, " ")
129         if (words[0] ~ /^ПЗПІ-23-[0-9]+$/) {
130             print "multiGroup"
131             exit
132         } else if (words[4] ~ /^ПЗПІ-23-[0-9]+$/) {
133             print "singleGroup:" words[4]
134             exit
135         }
136     }')
137
138 if [[ "$mode" =~ ^singleGroup:(.*) ]]; then
139     GROUP="${BASH_REMATCH[1]}"
140     MODE="singleGroup"
141
142     if [ "$QUIET" = "false" ]; then
143                 echo "У файлі знайдено розклад лише для однієї групи: $GROUP"
144                 echo "Розклад для $GROUP:"
145
146             # Вивести всі рядки, що відповідають одній групі
147             cat "$INPUT_FILE" | sed 's/\r/\n/g' | iconv -f cp1251 -t utf-8
148     fi
149
150 else
151     MODE="multiGroup"
152     echo "Розклад для групи: $GROUP"
153     if [ "$QUIET" = "false" ]; then
154         cat "$INPUT_FILE" | sed 's/\r/\n/g' | iconv -f cp1251 -t utf-8 | awk -v group="$GROUP" '
155             BEGIN { FPAT="[^,]*|\"[^\"]*\"" }
156             NR > 1 {
157                 gsub(/^"|"$/, "", $1)
158                 if ($1 ~ (group ", ")) { next }
159                 split($1, words, /[ ,;]+/)
160                     for (i = 1; i <= length(words); i++) {
161                         gsub(/^ +| +$/, "", words[i])
162                         if (words[i] == group) {
163                                 print
164                             break
165                         }
166                     }
167             }'
168     fi
169 fi
170
171
Б.5 Формування структурованих записів для календаря: підготовка та фільтрація CSV-рядків
172 # Формуємо CSV для Google Календаря
173 output_file=$(echo "$INPUT_FILE" | sed 's/TimeTable/Google_TimeTable/')
174 echo "Формування розкладу для Google Календаря: $output_file"
175
176 tmp_data=$(mktemp)
177 sorted_data=$(mktemp)
178
179 sed 's/\r/\n/g' "$INPUT_FILE" | iconv -f cp1251 -t utf-8 | awk -v GROUP="$GROUP" -v MODE="$MODE" '
180 BEGIN {
181     FS=","; OFS="\t"
182 }
183 NR == 1 { next }
184
185 function format_sort_key(date, time) {
186     split(date, dmy, ".")
187     split(time, hm, ":")
188     return sprintf("%04d%02d%02d%02d%02d", dmy[3], dmy[2], dmy[1], hm[1], hm[2])
189 }
190
191 function trim_quotes(s) {
192     gsub(/^"|"$/, "", s)
193     return s
194 }
195
196 {
197     line = $0
198     match(line, /"[0-3][0-9]\.[0-1][0-9]\.[0-9]{4}"/)
199     if (RSTART == 0) { next }
200
201     field1 = substr(line, 1, RSTART - 2)
202     rest = substr(line, RSTART)
203
204     n = 0; in_quotes = 0; field = ""
205     for (i = 1; i <= length(rest); i++) {
206         c = substr(rest, i, 1)
207         if (c == "\"") in_quotes = !in_quotes
208         else if (c == "," && !in_quotes) {
209             fields[++n] = field
210             field = ""
211         } else {
212             field = field c
213         }
214     }
215     fields[++n] = field
216     for (i = 1; i <= n; i++) fields[i] = trim_quotes(fields[i])
217     if (n < 12) next
218
219 if (MODE == "singleGroup") {
220     subject = trim_quotes(field1)
221 }
222 else {
223
224     match(field1, /(ПЗПІ-[0-9]+-[0-9]+)[[:space:]]*-[[:space:]]*/, m)
225     found_group = m[1]
226
227     if (found_group != GROUP)
228         next
229
230     field1 = substr(field1, RSTART + RLENGTH)
231     gsub(/^[[:space:]]+/, "", field1)
232     subject = field1
233     gsub(/^"|"$/, "", subject)
234 }
235
236     desc = fields[11]
237     type = "Інше"
238
239     if (desc ~ /Лб/)
240         type = "Лб"
241     else if (desc ~ /Лк/)
242         type = "Лк"
243     else if (desc ~ /Пз/)
244         type = "Пз"
245     else if (desc ~ /Екз/i)
246         type = "Екз"
247
248     sort_key = format_sort_key(fields[1], fields[2])
249
250     print subject, type, fields[1], fields[2], fields[3], fields[4], desc, sort_key
251 }' > "$tmp_data"
252
Б.6 Хронологічне сортування записів для календаря
253 sort -t $'\t' -k8,8 "$tmp_data" > "$sorted_data"
254
Б.7 Генерація фінального CSV: підготовка до імпорт
255 awk -F'\t' '
256 BEGIN {
257     OFS = ","
258     print "Subject", "Start Date", "Start Time", "End Date", "End Time", "Description"
259 }
260
261 function format_date(date) {
262     split(date, dmy, ".")
263     return sprintf("%02d/%02d/%04d", dmy[2], dmy[1], dmy[3])
264 }
265
266 function format_time(time) {
267     split(time, hmin, ":")
268     h = hmin[1] + 0
269     min = hmin[2]
270     ap = (h >= 12) ? "PM" : "AM"
271     if (h == 0) h = 12
272     else if (h > 12) h -= 12
273     return sprintf("%02d:%s %s", h, min, ap)
274 }
275 {
276     subj_key = $1 "_" $2
277     date_key = $3 "_" $7
278
279     if ($2 == "Лб") {
280         if (!(date_key in lab_seen)) {
281             count[subj_key]++
282             lab_seen[date_key] = count[subj_key]
283         }
284         number = lab_seen[date_key]
285     } else {
286         count[subj_key]++
287         number = count[subj_key]
288     }
289
290     subject_full = $1 "; №" number
291     start_date = format_date($3)
292     start_time = format_time($4)
293     end_date = format_date($5)
294     end_time = format_time($6)
295     desc = $7
296
297     printf "\"%s\",\"%s\",\"%s\",\"%s\",\"%s\",\"%s\"\n", \
298         subject_full, start_date, start_time, end_date, end_time, desc
299 }' "$sorted_data" > "$output_file"
300
Б.8 Післяобробка: вивід CSV і прибирання тимчасових файлів
301 if [[ "$QUIET" == false ]]; then
302     cat "$output_file"
303     echo "Google-file сформований"
304 else
305     echo "Google-file сформований"
306 fi
307
308 echo "Назва вихідного файлу: $output_file"
309
310 rm -f "$tmp_data" "$sorted_data"
