  1 #!/bin/bash
  2
  3 VERSION="1.0"
  4 INPUT_FILE=""
  5 GROUP=""
  6 QUIET=false
  7
  8 while [[ $# -gt 0 ]]; do
  9     arg="$1"
 10
 11     if [[ "$arg" == "--help" ]]; then
 12         echo "Використання: $0 [--help | --version] | [[-q|--quiet] [академ_група] файл_із_cist.csv]"
 13         echo "  --help        Відображення довідки"
 14         echo "  --version     Відображення версію скрипта"
 15         echo "  -q, --quiet   Не виводити вміст TimeTable_.._.._20.. та сформованого Google_.._.._20.. файлів у stdout"
 16         exit 0
 17
 18     elif [[ "$arg" == "--version" ]]; then
 19         echo "Версія: $VERSION"
 20         exit 0
 21
 22     elif [[ "$arg" == "-q" || "$arg" == "--quiet" ]]; then
 23         QUIET=true
 24
 25     elif [[ "$arg" == *.csv ]]; then
 26         INPUT_FILE="$arg"
 27
 28     else
 29         GROUP="$arg"
 30     fi
 31
 32     shift
 33 done
 34
 35 if [ -z "$INPUT_FILE" ]; then
 36
 37     files=($(ls | grep -E '^TimeTable_.._.._20..\.csv'))
 38
 39     if [ ${#files[@]} -eq 0 ]; then
 40         echo "Помилка: файли TimeTable_ДД_ММ_РРРР.csv не знайдено" >&2
 41         exit 1
 42     fi
 43
 44     sorted_files=()
 45     for file in "${files[@]}"; do
 46
 47         day=${file:10:2}
 48         month=${file:13:2}
 49         year=${file:16:4}
 50
 51         sorted_files+=("${year}${month}${day} $file")
 52     done
 53
 54     sorted_files=($(printf "%s\n" "${sorted_files[@]}" | sort | awk '{print $2}'))
 55
 56     sorted_files+=("Вийти")
 57
 58     echo "Оберіть файл із розкладом:"
 59     select chosen_file in "${sorted_files[@]}"; do
 60         if [ "$chosen_file" = "Вийти" ]; then
 61             echo "Вихід із програми."
 62             exit 0
 63         fi
 64
 65         if [ -n "$chosen_file" ]; then
 66             echo "Обрано файл: $chosen_file"
 67             INPUT_FILE="$chosen_file"
 68             break
 69         else
 70             echo "Помилка: виберіть номер зі списку."
 71         fi
 72     done
 73 fi
 74
 75 if [ ! -f "$INPUT_FILE" ]; then
 76     echo "Помилка: файлу $INPUT_FILE немає у поточній директорії. Передивіться ще раз назву та розширення файлу .csv" >&2
 77     exit 2
 78 fi
 79
 80 groups=($(cat "$INPUT_FILE" | sed 's/\r/\n/g' | iconv -f cp1251 -t utf-8 | awk '
 81     BEGIN { FPAT="[^,]*|\"[^\"]*\"" }
 82     NR > 1 {
 83         gsub(/^"|"$/, "", $1)
 84         split($1, words, " ")
 85         for (i = 1; i <= length(words); i++) {
 86             if (words[i] ~ /^ПЗПІ-23-[0-9]+$/) {
 87                 print words[i]
 88             }
 89         }
 90     }' | sort | uniq | sort -t '-' -k 3 -n))
 91
 92 if [ ${#groups[@]} -eq 0 ]; then
 93     echo "Помилка: у файлі $INPUT_FILE не знайдено груп ПЗПІ-23-?" >&2
 94     exit 3
 95 fi
 96
 97 if [ -n "$GROUP" ] && [ ${#groups[@]} -eq 1 ] && [ "$GROUP" != "${groups[0]}" ]; then
 98     echo "Цей файл містить лише розклад для групи: ${groups[0]}"
 99     exit 0
100 fi
101
102 if [ -z "$GROUP" ]; then
103     if [ ${#groups[@]} -eq 1 ]; then
104         GROUP="${groups[0]}"
105         echo "Одна доступна група: $GROUP"
106     else
107         echo "Доступні групи:"
108         groups+=("Повернутись")
109         select chosen_group in "${groups[@]}"; do
110             if [ "$chosen_group" = "Повернутись" ]; then
111                 echo "Повернення до вибору файлу."
112                 exit 0
113             elif [ -n "$chosen_group" ]; then
114                 echo "Обрано групу: $chosen_group"
115                 GROUP="$chosen_group"
116                 break
117             else
118                 echo "Помилка: зробіть правильний вибір (номер зі списку)."
119             fi
120         done
121     fi
122 fi
123
124 mode=$(cat "$INPUT_FILE" | sed 's/\r/\n/g' | iconv -f cp1251 -t utf-8 2>/dev/null | awk '
125     BEGIN { FPAT="[^,]*|\"[^\"]*\"" }
126     NR > 1 {
127         gsub(/^"|"$/, "", $1)
128         split($1, words, " ")
129         if (words[0] ~ /^ПЗПІ-23-[0-9]+$/) {
130             print "multiGroup"
131             exit
132         } else if (words[4] ~ /^ПЗПІ-23-[0-9]+$/) {
133             print "singleGroup:" words[4]
134             exit
135         }
136     }')
137
138 if [[ "$mode" =~ ^singleGroup:(.*) ]]; then
139     GROUP="${BASH_REMATCH[1]}"
140     SELECTED_GROUP="$GROUP"
141     MODE="singleGroup"
142
143     if [ "$QUIET" = "false" ]; then
144                 echo "У файлі знайдено розклад лише для однієї групи: $GROUP"
145                 echo "Розклад для $GROUP:"
146
147             # Вивести всі рядки, що відповідають одній групі
148             cat "$INPUT_FILE" | sed 's/\r/\n/g' | iconv -f cp1251 -t utf-8
149     fi
150
151 else
152     MODE="multiGroup"
153     SELECTED_GROUP="$GROUP"
154     echo "Розклад для групи: $GROUP"
155     if [ "$QUIET" = "false" ]; then
156         cat "$INPUT_FILE" | sed 's/\r/\n/g' | iconv -f cp1251 -t utf-8 | awk -v group="$GROUP" '
157             BEGIN { FPAT="[^,]*|\"[^\"]*\"" }
158             NR == 1 { print; next }
159             {
160                 gsub(/^"|"$/, "", $1)
161                 if ($1 ~ (group ",")) { next }
162                 split($1, words, /[ ,;]+/)
163                     for (i = 1; i <= length(words); i++) {
164                         gsub(/^ +| +$/, "", words[i])
165                         if (words[i] == group) {
166                                 print
167                             break
168                         }
169                     }
170             }'
171     fi
172 fi
173
174
175 # Формуємо CSV для Google Календаря
176 # Вихідний файл
177 output_file=$(echo "$INPUT_FILE" | sed 's/TimeTable/Google_TimeTable/')
178 echo "Формування розкладу для Google Календаря: $output_file"
179
180 tmp_data=$(mktemp)
181 sorted_data=$(mktemp)
182
183 sed 's/\r/\n/g' "$INPUT_FILE" | iconv -f cp1251 -t utf-8 | awk -v GROUP="$GROUP" -v MODE="$MODE" '
184 BEGIN {
185     FS=","; OFS="\t"
186 }
187 NR == 1 { next }
188
189 function format_sort_key(date, time) {
190     split(date, dmy, ".")
191     split(time, hm, ":")
192     return sprintf("%04d%02d%02d%02d%02d", dmy[3], dmy[2], dmy[1], hm[1], hm[2])
193 }
194
195 function trim_quotes(s) {
196     gsub(/^"|"$/, "", s)
197     return s
198 }
199
200 {
201     line = $0
202     match(line, /"[0-3][0-9]\.[0-1][0-9]\.[0-9]{4}"/)
203     if (RSTART == 0) next
204
205     field1 = substr(line, 1, RSTART - 2)
206     rest = substr(line, RSTART)
207
208     n = 0; in_quotes = 0; field = ""
209     for (i = 1; i <= length(rest); i++) {
210         c = substr(rest, i, 1)
211         if (c == "\"") in_quotes = !in_quotes
212         else if (c == "," && !in_quotes) {
213             fields[++n] = field
214             field = ""
215         } else {
216             field = field c
217         }
218     }
219     fields[++n] = field
220     for (i = 1; i <= n; i++) fields[i] = trim_quotes(fields[i])
221     if (n < 12) next
222
223 if (MODE == "singleGroup") {
224     subject = trim_quotes(field1)
225 }
226 else {
227
228     match(field1, /(ПЗПІ-[0-9]+-[0-9]+)[[:space:]]*-[[:space:]]*/, m)
229     found_group = m[1]
230
231     if (found_group != GROUP)
232         next
233
234     field1 = substr(field1, RSTART + RLENGTH)
235     gsub(/^[[:space:]]+/, "", field1)
236     subject = field1
237     gsub(/^"|"$/, "", subject)
238 }
239
240     desc = fields[11]
241     type = "Інше"
242
243     if (desc ~ /Лб/)
244         type = "Лб"
245     else if (desc ~ /Лк/)
246         type = "Лк"
247     else if (desc ~ /Пз/)
248         type = "Пз"
249     else if (desc ~ /Екз/i)
250         type = "Екз"
251
252     sort_key = format_sort_key(fields[1], fields[2])
253
254     print subject, type, fields[1], fields[2], fields[3], fields[4], desc, sort_key
255 }' > "$tmp_data"
256
257 sort -t $'\t' -k8,8 "$tmp_data" > "$sorted_data"
258
259 awk -F'\t' '
260 BEGIN {
261     OFS = ","
262     print "Subject", "Start Date", "Start Time", "End Date", "End Time", "Description"
263 }
264
265 function format_date(date) {
266     split(date, dmy, ".")
267     return sprintf("%02d/%02d/%04d", dmy[2], dmy[1], dmy[3])
268 }
269
270 function format_time(time) {
271     split(time, hmin, ":")
272     h = hmin[1] + 0
273     min = hmin[2]
274     ap = (h >= 12) ? "PM" : "AM"
275     if (h == 0) h = 12
276     else if (h > 12) h -= 12
277     return sprintf("%02d:%s %s", h, min, ap)
278 }
279 {
280     subj_key = $1 "_" $2
281     date_key = $3 "_" $7
282
283     if ($2 == "Лб") {
284         if (!(date_key in lab_seen)) {
285             count[subj_key]++
286             lab_seen[date_key] = count[subj_key]
287         }
288         number = lab_seen[date_key]
289     } else {
290         count[subj_key]++
291         number = count[subj_key]
292     }
293
294     subject_full = $1 "; №" number
295     start_date = format_date($3)
296     start_time = format_time($4)
297     end_date = format_date($5)
298     end_time = format_time($6)
299     desc = $7
300
301     printf "\"%s\",\"%s\",\"%s\",\"%s\",\"%s\",\"%s\"\n", \
302         subject_full, start_date, start_time, end_date, end_time, desc
303 }' "$sorted_data" > "$output_file"
304
305 if [[ "$QUIET" == false ]]; then
306     cat "$output_file"
307     echo "Google-file сформований"
308 else
309     echo "Google-file сформований"
310 fi
311
312 echo "Назва вихідного файлу: $output_file"
313
314 rm -f "$tmp_data" "$sorted_data"
