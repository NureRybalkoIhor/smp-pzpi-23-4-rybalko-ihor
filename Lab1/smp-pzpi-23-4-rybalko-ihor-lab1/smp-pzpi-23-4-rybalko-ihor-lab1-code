  1 #!/bin/bash
  2
  3 VERSION="1.0"
  4 INPUT_FILE=""
  5 GROUP=""
  6 QUIET=false
  7
  8 while [[ $# -gt 0 ]]; do
  9     arg="$1"
 10
 11     if [[ "$arg" == "--help" ]]; then
 12         echo "Використання: $0 [--help | --version] | [[-q|--quiet] [академ_група] файл_із_cist.csv]"
 13         echo "  --help        Відображення довідки"
 14         echo "  --version     Відображення версію скрипта"
 15         echo "  -q, --quiet   Не виводити вміст TimeTable_.._.._20.. та сформованого Google_.._.._20.. файлів у stdout"
 16         exit 0
 17
 18     elif [[ "$arg" == "--version" ]]; then
 19         echo "Версія: $VERSION"
 20         exit 0
 21
 22     elif [[ "$arg" == "-q" || "$arg" == "--quiet" ]]; then
 23         QUIET=true
 24
 25     elif [[ "$arg" == *.csv ]]; then
 26         INPUT_FILE="$arg"
 27
 28     else
 29         GROUP="$arg"
 30     fi
 31
 32     shift
 33 done
 34
 35 if [ -z "$INPUT_FILE" ]; then
 36
 37     files=($(ls | grep -E '^TimeTable_.._.._20..\.csv'))
 38
 39     if [ ${#files[@]} -eq 0 ]; then
 40         echo "Помилка: файли TimeTable_ДД_ММ_РРРР.csv не знайдено" >&2
 41         exit 1
 42     fi
 43
 44     sorted_files=()
 45     for file in "${files[@]}"; do
 46
 47         day=${file:10:2}
 48         month=${file:13:2}
 49         year=${file:16:4}
 50
 51         sorted_files+=("${year}${month}${day} $file")
 52     done
 53
 54     sorted_files=($(printf "%s\n" "${sorted_files[@]}" | sort | awk '{print $2}'))
 55
 56     sorted_files+=("Вийти")
 57
 58     echo "Оберіть файл із розкладом:"
 59     select chosen_file in "${sorted_files[@]}"; do
 60         if [ "$chosen_file" = "Вийти" ]; then
 61             echo "Вихід із програми."
 62             exit 0
 63         fi
 64
 65         if [ -n "$chosen_file" ]; then
 66             echo "Обрано файл: $chosen_file"
 67             INPUT_FILE="$chosen_file"
 68             break
 69         else
 70             echo "Помилка: виберіть номер зі списку."
 71         fi
 72     done
 73 fi
 74
 75 if [ ! -f "$INPUT_FILE" ]; then
 76     echo "Помилка: файлу $INPUT_FILE немає у поточній директорії. Передивіться ще раз назву та розширення файлу .csv" >&2
 77     exit 2
 78 fi
 79
 80 groups=($(cat "$INPUT_FILE" | sed 's/\r/\n/g' | iconv -f cp1251 -t utf-8 | awk '
 81     BEGIN { FPAT="[^,]*|\"[^\"]*\"" }
 82     NR > 1 {
 83         gsub(/^"|"$/, "", $1)
 84         split($1, words, " ")
 85         for (i = 1; i <= length(words); i++) {
 86             if (words[i] ~ /^ПЗПІ-23-[0-9]+$/) {
 87                 print words[i]
 88             }
 89         }
 90     }' | sort | uniq | sort -t '-' -k 3 -n))
 91
 92 if [ ${#groups[@]} -eq 0 ]; then
 93     echo "Помилка: у файлі $INPUT_FILE не знайдено груп ПЗПІ-23-?" >&2
 94     exit 3
 95 fi
 96
 97 if [ -n "$GROUP" ] && [ ${#groups[@]} -eq 1 ] && [ "$GROUP" != "${groups[0]}" ]; then
 98     echo "Цей файл містить лише розклад для групи: ${groups[0]}"
 99     exit 0
100 fi
101
102 if [ -z "$GROUP" ]; then
103     if [ ${#groups[@]} -eq 1 ]; then
104         GROUP="${groups[0]}"
105         echo "Одна доступна група: $GROUP"
106     else
107         echo "Доступні групи:"
108         groups+=("Повернутись")
109         select chosen_group in "${groups[@]}"; do
110             if [ "$chosen_group" = "Повернутись" ]; then
111                 echo "Повернення до вибору файлу."
112                 exit 0
113             elif [ -n "$chosen_group" ]; then
114                 echo "Обрано групу: $chosen_group"
115                 GROUP="$chosen_group"
116                 break
117             else
118                 echo "Помилка: зробіть правильний вибір (номер зі списку)."
119             fi
120         done
121     fi
122 fi
123
124 mode=$(cat "$INPUT_FILE" | sed 's/\r/\n/g' | iconv -f cp1251 -t utf-8 | awk '
125     BEGIN { FPAT="[^,]*|\"[^\"]*\"" }
126     NR > 1 {
127         gsub(/^"|"$/, "", $1)
128         split($1, words, " ")
129         if (words[0] ~ /^ПЗПІ-23-[0-9]+$/) {
130             print "multiGroup"
131             exit
132         } else if (words[4] ~ /^ПЗПІ-23-[0-9]+$/) {
133             print "singleGroup:" words[4]
134             exit
135         }
136     }')
137
138 if [[ "$mode" =~ ^singleGroup:(.*) ]]; then
139     GROUP="${BASH_REMATCH[1]}"
140     MODE="singleGroup"
141
142     if [ "$QUIET" = "false" ]; then
143                 echo "У файлі знайдено розклад лише для однієї групи: $GROUP"
144                 echo "Розклад для $GROUP:"
145
146             # Вивести всі рядки, що відповідають одній групі
147             cat "$INPUT_FILE" | sed 's/\r/\n/g' | iconv -f cp1251 -t utf-8
148     fi
149
150 else
151     MODE="multiGroup"
152     echo "Розклад для групи: $GROUP"
153     if [ "$QUIET" = "false" ]; then
154         cat "$INPUT_FILE" | sed 's/\r/\n/g' | iconv -f cp1251 -t utf-8 | awk -v group="$GROUP" '
155             BEGIN { FPAT="[^,]*|\"[^\"]*\"" }
156             NR > 1 {
157                 gsub(/^"|"$/, "", $1)
158                 if ($1 ~ (group ", ")) { next }
159                 split($1, words, /[ ,;]+/)
160                     for (i = 1; i <= length(words); i++) {
161                         gsub(/^ +| +$/, "", words[i])
162                         if (words[i] == group) {
163                                 print
164                             break
165                         }
166                     }
167             }'
168     fi
169 fi
170
171
172 # Формуємо CSV для Google Календаря
173 output_file=$(echo "$INPUT_FILE" | sed 's/TimeTable/Google_TimeTable/')
174 echo "Формування розкладу для Google Календаря: $output_file"
175
176 tmp_data=$(mktemp)
177 sorted_data=$(mktemp)
178
179 sed 's/\r/\n/g' "$INPUT_FILE" | iconv -f cp1251 -t utf-8 | awk -v GROUP="$GROUP" -v MODE="$MODE" '
180 BEGIN {
181     FS=","; OFS="\t"
182 }
183 NR == 1 { next }
184
185 function format_sort_key(date, time) {
186     split(date, dmy, ".")
187     split(time, hm, ":")
188     return sprintf("%04d%02d%02d%02d%02d", dmy[3], dmy[2], dmy[1], hm[1], hm[2])
189 }
190
191 function trim_quotes(s) {
192     gsub(/^"|"$/, "", s)
193     return s
194 }
195
196 {
197     line = $0
198     match(line, /"[0-3][0-9]\.[0-1][0-9]\.[0-9]{4}"/)
199     if (RSTART == 0) { next }
200
201     field1 = substr(line, 1, RSTART - 2)
202     rest = substr(line, RSTART)
203
204     n = 0; in_quotes = 0; field = ""
205     for (i = 1; i <= length(rest); i++) {
206         c = substr(rest, i, 1)
207         if (c == "\"") in_quotes = !in_quotes
208         else if (c == "," && !in_quotes) {
209             fields[++n] = field
210             field = ""
211         } else {
212             field = field c
213         }
214     }
215     fields[++n] = field
216     for (i = 1; i <= n; i++) fields[i] = trim_quotes(fields[i])
217     if (n < 12) next
218
219 if (MODE == "singleGroup") {
220     subject = trim_quotes(field1)
221 }
222 else {
223
224     match(field1, /(ПЗПІ-[0-9]+-[0-9]+)[[:space:]]*-[[:space:]]*/, m)
225     found_group = m[1]
226
227     if (found_group != GROUP)
228         next
229
230     field1 = substr(field1, RSTART + RLENGTH)
231     gsub(/^[[:space:]]+/, "", field1)
232     subject = field1
233     gsub(/^"|"$/, "", subject)
234 }
235
236     desc = fields[11]
237     type = "Інше"
238
239     if (desc ~ /Лб/)
240         type = "Лб"
241     else if (desc ~ /Лк/)
242         type = "Лк"
243     else if (desc ~ /Пз/)
244         type = "Пз"
245     else if (desc ~ /Екз/i)
246         type = "Екз"
247
248     sort_key = format_sort_key(fields[1], fields[2])
249
250     print subject, type, fields[1], fields[2], fields[3], fields[4], desc, sort_key
251 }' > "$tmp_data"
252
253 sort -t $'\t' -k8,8 "$tmp_data" > "$sorted_data"
254
255 awk -F'\t' '
256 BEGIN {
257     OFS = ","
258     print "Subject", "Start Date", "Start Time", "End Date", "End Time", "Description"
259 }
260
261 function format_date(date) {
262     split(date, dmy, ".")
263     return sprintf("%02d/%02d/%04d", dmy[2], dmy[1], dmy[3])
264 }
265
266 function format_time(time) {
267     split(time, hmin, ":")
268     h = hmin[1] + 0
269     min = hmin[2]
270     ap = (h >= 12) ? "PM" : "AM"
271     if (h == 0) h = 12
272     else if (h > 12) h -= 12
273     return sprintf("%02d:%s %s", h, min, ap)
274 }
275 {
276     subj_key = $1 "_" $2
277     date_key = $3 "_" $7
278
279     if ($2 == "Лб") {
280         if (!(date_key in lab_seen)) {
281             count[subj_key]++
282             lab_seen[date_key] = count[subj_key]
283         }
284         number = lab_seen[date_key]
285     } else {
286         count[subj_key]++
287         number = count[subj_key]
288     }
289
290     subject_full = $1 "; №" number
291     start_date = format_date($3)
292     start_time = format_time($4)
293     end_date = format_date($5)
294     end_time = format_time($6)
295     desc = $7
296
297     printf "\"%s\",\"%s\",\"%s\",\"%s\",\"%s\",\"%s\"\n", \
298         subject_full, start_date, start_time, end_date, end_time, desc
299 }' "$sorted_data" > "$output_file"
300
301 if [[ "$QUIET" == false ]]; then
302     cat "$output_file"
303     echo "Google-file сформований"
304 else
305     echo "Google-file сформований"
306 fi
307
308 echo "Назва вихідного файлу: $output_file"
309
310 rm -f "$tmp_data" "$sorted_data"
